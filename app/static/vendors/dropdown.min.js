// deno-lint-ignore-file
var ht = ["top", "right", "bottom", "left"],
  pt = ["start", "end"],
  Gt = ht.reduce((t, e) => t.concat(e, e + "-" + pt[0], e + "-" + pt[1]), []),
  Y = Math.min,
  k = Math.max,
  G = Math.round,
  J = Math.floor,
  C = (t) => ({ x: t, y: t });
function et() {
  return typeof window < "u";
}
function M(t) {
  return wt(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function A(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null
    ? void 0
    : e.defaultView) || window;
}
function E(t) {
  var e;
  return (e = (wt(t) ? t.ownerDocument : t.document) || window.document) == null
    ? void 0
    : e.documentElement;
}
function wt(t) {
  return et() ? t instanceof Node || t instanceof A(t).Node : !1;
}
function P(t) {
  return et() ? t instanceof Element || t instanceof A(t).Element : !1;
}
function T(t) {
  return et() ? t instanceof HTMLElement || t instanceof A(t).HTMLElement : !1;
}
function yt(t) {
  return !et() || typeof ShadowRoot > "u"
    ? !1
    : t instanceof ShadowRoot || t instanceof A(t).ShadowRoot;
}
function q(t) {
  let { overflow: e, overflowX: n, overflowY: i, display: r } = O(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + i + n) &&
    !["inline", "contents"].includes(r);
}
function xt(t) {
  return ["table", "td", "th"].includes(M(t));
}
function Q(t) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function it(t) {
  let e = nt(), n = P(t) ? O(t) : t;
  return n.transform !== "none" || n.perspective !== "none" ||
    (n.containerType ? n.containerType !== "normal" : !1) ||
    !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) ||
    !e && (n.filter ? n.filter !== "none" : !1) ||
    ["transform", "perspective", "filter"].some((i) =>
      (n.willChange || "").includes(i)
    ) ||
    ["paint", "layout", "strict", "content"].some((i) =>
      (n.contain || "").includes(i)
    );
}
function vt(t) {
  let e = S(t);
  for (; T(e) && !N(e);) {
    if (it(e)) return e;
    if (Q(e)) return null;
    e = S(e);
  }
  return null;
}
function nt() {
  return typeof CSS > "u" || !CSS.supports
    ? !1
    : CSS.supports("-webkit-backdrop-filter", "none");
}
function N(t) {
  return ["html", "body", "#document"].includes(M(t));
}
function O(t) {
  return A(t).getComputedStyle(t);
}
function Z(t) {
  return P(t)
    ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }
    : { scrollLeft: t.scrollX, scrollTop: t.scrollY };
}
function S(t) {
  if (M(t) === "html") return t;
  let e = t.assignedSlot || t.parentNode || yt(t) && t.host || E(t);
  return yt(e) ? e.host : e;
}
function bt(t) {
  let e = S(t);
  return N(e)
    ? t.ownerDocument ? t.ownerDocument.body : t.body
    : T(e) && q(e)
    ? e
    : bt(e);
}
function B(t, e, n) {
  var i;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  let r = bt(t),
    a = r === ((i = t.ownerDocument) == null ? void 0 : i.body),
    o = A(r);
  if (a) {
    let s = rt(o);
    return e.concat(
      o,
      o.visualViewport || [],
      q(r) ? r : [],
      s && n ? B(s) : [],
    );
  }
  return e.concat(r, B(r, [], n));
}
function rt(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
var at = ["top", "right", "bottom", "left"],
  At = ["start", "end"],
  lt = at.reduce((t, e) => t.concat(e, e + "-" + At[0], e + "-" + At[1]), []),
  _ = Math.min,
  H = Math.max;
var Qt = { left: "right", right: "left", bottom: "top", top: "bottom" },
  Zt = { start: "end", end: "start" };
function st(t, e, n) {
  return H(t, _(e, n));
}
function W(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function F(t) {
  return t.split("-")[0];
}
function L(t) {
  return t.split("-")[1];
}
function ct(t) {
  return t === "x" ? "y" : "x";
}
function ft(t) {
  return t === "y" ? "height" : "width";
}
function I(t) {
  return ["top", "bottom"].includes(F(t)) ? "y" : "x";
}
function ut(t) {
  return ct(I(t));
}
function Rt(t, e, n) {
  n === void 0 && (n = !1);
  let i = L(t),
    r = ut(t),
    a = ft(r),
    o = r === "x"
      ? i === (n ? "end" : "start") ? "right" : "left"
      : i === "start"
      ? "bottom"
      : "top";
  return e.reference[a] > e.floating[a] && (o = ot(o)), [o, ot(o)];
}
function Pt(t) {
  return t.replace(/start|end/g, (e) => Zt[e]);
}
function ot(t) {
  return t.replace(/left|right|bottom|top/g, (e) => Qt[e]);
}
function te(t) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...t };
}
function Ot(t) {
  return typeof t != "number"
    ? te(t)
    : { top: t, right: t, bottom: t, left: t };
}
function z(t) {
  let { x: e, y: n, width: i, height: r } = t;
  return {
    width: i,
    height: r,
    top: n,
    left: e,
    right: e + i,
    bottom: n + r,
    x: e,
    y: n,
  };
}
function Et(t, e, n) {
  let { reference: i, floating: r } = t,
    a = I(e),
    o = ut(e),
    s = ft(o),
    l = F(e),
    c = a === "y",
    u = i.x + i.width / 2 - r.width / 2,
    d = i.y + i.height / 2 - r.height / 2,
    m = i[s] / 2 - r[s] / 2,
    f;
  switch (l) {
    case "top":
      f = { x: u, y: i.y - r.height };
      break;
    case "bottom":
      f = { x: u, y: i.y + i.height };
      break;
    case "right":
      f = { x: i.x + i.width, y: d };
      break;
    case "left":
      f = { x: i.x - r.width, y: d };
      break;
    default:
      f = { x: i.x, y: i.y };
  }
  switch (L(e)) {
    case "start":
      f[o] -= m * (n && c ? -1 : 1);
      break;
    case "end":
      f[o] += m * (n && c ? -1 : 1);
      break;
  }
  return f;
}
var Ct = async (t, e, n) => {
  let {
      placement: i = "bottom",
      strategy: r = "absolute",
      middleware: a = [],
      platform: o,
    } = n,
    s = a.filter(Boolean),
    l = await (o.isRTL == null ? void 0 : o.isRTL(e)),
    c = await o.getElementRects({ reference: t, floating: e, strategy: r }),
    { x: u, y: d } = Et(c, i, l),
    m = i,
    f = {},
    h = 0;
  for (let p = 0; p < s.length; p++) {
    let { name: y, fn: g } = s[p],
      { x: w, y: x, data: b, reset: v } = await g({
        x: u,
        y: d,
        initialPlacement: i,
        placement: m,
        strategy: r,
        middlewareData: f,
        rects: c,
        platform: o,
        elements: { reference: t, floating: e },
      });
    u = w ?? u,
      d = x ?? d,
      f = { ...f, [y]: { ...f[y], ...b } },
      v && h <= 50 && (h++,
        typeof v == "object" &&
        (v.placement && (m = v.placement),
          v.rects && (c = v.rects === !0
            ? await o.getElementRects({
              reference: t,
              floating: e,
              strategy: r,
            })
            : v.rects),
          { x: u, y: d } = Et(c, m, l)),
        p = -1);
  }
  return { x: u, y: d, placement: m, strategy: r, middlewareData: f };
};
async function j(t, e) {
  var n;
  e === void 0 && (e = {});
  let { x: i, y: r, platform: a, rects: o, elements: s, strategy: l } = t,
    {
      boundary: c = "clippingAncestors",
      rootBoundary: u = "viewport",
      elementContext: d = "floating",
      altBoundary: m = !1,
      padding: f = 0,
    } = W(e, t),
    h = Ot(f),
    p = s[m ? d === "floating" ? "reference" : "floating" : d],
    y = z(
      await a.getClippingRect({
        element:
          (n = await (a.isElement == null ? void 0 : a.isElement(p))) == null ||
            n
            ? p
            : p.contextElement ||
              await (a.getDocumentElement == null
                ? void 0
                : a.getDocumentElement(s.floating)),
        boundary: c,
        rootBoundary: u,
        strategy: l,
      }),
    ),
    g = d === "floating"
      ? { x: i, y: r, width: o.floating.width, height: o.floating.height }
      : o.reference,
    w =
      await (a.getOffsetParent == null
        ? void 0
        : a.getOffsetParent(s.floating)),
    x = await (a.isElement == null ? void 0 : a.isElement(w))
      ? await (a.getScale == null ? void 0 : a.getScale(w)) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    b = z(
      a.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
          elements: s,
          rect: g,
          offsetParent: w,
          strategy: l,
        })
        : g,
    );
  return {
    top: (y.top - b.top + h.top) / x.y,
    bottom: (b.bottom - y.bottom + h.bottom) / x.y,
    left: (y.left - b.left + h.left) / x.x,
    right: (b.right - y.right + h.right) / x.x,
  };
}
function ee(t, e, n) {
  return (t
    ? [...n.filter((i) => L(i) === t), ...n.filter((i) => L(i) !== t)]
    : n.filter((i) => F(i) === i)).filter((i) =>
      t ? L(i) === t || (e ? Pt(i) !== i : !1) : !0
    );
}
var St = function (t) {
  return t === void 0 && (t = {}), {
    name: "autoPlacement",
    options: t,
    async fn(e) {
      var n, i, r;
      let {
          rects: a,
          middlewareData: o,
          placement: s,
          platform: l,
          elements: c,
        } = e,
        {
          crossAxis: u = !1,
          alignment: d,
          allowedPlacements: m = lt,
          autoAlignment: f = !0,
          ...h
        } = W(t, e),
        p = d !== void 0 || m === lt ? ee(d || null, f, m) : m,
        y = await j(e, h),
        g = ((n = o.autoPlacement) == null ? void 0 : n.index) || 0,
        w = p[g];
      if (w == null) return {};
      let x = Rt(
        w,
        a,
        await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
      );
      if (s !== w) return { reset: { placement: p[0] } };
      let b = [y[F(w)], y[x[0]], y[x[1]]],
        v = [
          ...((i = o.autoPlacement) == null ? void 0 : i.overflows) || [],
          { placement: w, overflows: b },
        ],
        $ = p[g + 1];
      if ($) {
        return {
          data: { index: g + 1, overflows: v },
          reset: { placement: $ },
        };
      }
      let K = v.map((R) => {
          let D = L(R.placement);
          return [
            R.placement,
            D && u
              ? R.overflows.slice(0, 2).reduce((tt, Yt) => tt + Yt, 0)
              : R.overflows[0],
            R.overflows,
          ];
        }).sort((R, D) => R[1] - D[1]),
        U = ((r = K.filter((R) =>
            R[2].slice(0, L(R[0]) ? 2 : 3).every((D) =>
              D <= 0
            )
          )[0]) == null
          ? void 0
          : r[0]) || K[0][0];
      return U !== s
        ? { data: { index: g + 1, overflows: v }, reset: { placement: U } }
        : {};
    },
  };
};
function Tt(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width,
  };
}
function Lt(t) {
  return at.some((e) => t[e] >= 0);
}
var Dt = function (t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      let { rects: n } = e,
        { strategy: i = "referenceHidden", ...r } = W(t, e);
      switch (i) {
        case "referenceHidden": {
          let a = await j(e, { ...r, elementContext: "reference" }),
            o = Tt(a, n.reference);
          return {
            data: { referenceHiddenOffsets: o, referenceHidden: Lt(o) },
          };
        }
        case "escaped": {
          let a = await j(e, { ...r, altBoundary: !0 }),
            o = Tt(a, n.floating);
          return { data: { escapedOffsets: o, escaped: Lt(o) } };
        }
        default:
          return {};
      }
    },
  };
};
async function ie(t, e) {
  let { placement: n, platform: i, elements: r } = t,
    a = await (i.isRTL == null ? void 0 : i.isRTL(r.floating)),
    o = F(n),
    s = L(n),
    l = I(n) === "y",
    c = ["left", "top"].includes(o) ? -1 : 1,
    u = a && l ? -1 : 1,
    d = W(e, t),
    { mainAxis: m, crossAxis: f, alignmentAxis: h } = typeof d == "number"
      ? { mainAxis: d, crossAxis: 0, alignmentAxis: null }
      : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d };
  return s && typeof h == "number" && (f = s === "end" ? h * -1 : h),
    l ? { x: f * u, y: m * c } : { x: m * c, y: f * u };
}
var kt = function (t) {
    return t === void 0 && (t = 0), {
      name: "offset",
      options: t,
      async fn(e) {
        var n, i;
        let { x: r, y: a, placement: o, middlewareData: s } = e,
          l = await ie(e, t);
        return o === ((n = s.offset) == null ? void 0 : n.placement) &&
            (i = s.arrow) != null && i.alignmentOffset
          ? {}
          : { x: r + l.x, y: a + l.y, data: { ...l, placement: o } };
      },
    };
  },
  Ht = function (t) {
    return t === void 0 && (t = {}), {
      name: "shift",
      options: t,
      async fn(e) {
        let { x: n, y: i, placement: r } = e,
          {
            mainAxis: a = !0,
            crossAxis: o = !1,
            limiter: s = {
              fn: (y) => {
                let { x: g, y: w } = y;
                return { x: g, y: w };
              },
            },
            ...l
          } = W(t, e),
          c = { x: n, y: i },
          u = await j(e, l),
          d = I(F(r)),
          m = ct(d),
          f = c[m],
          h = c[d];
        if (a) {
          let y = m === "y" ? "top" : "left",
            g = m === "y" ? "bottom" : "right",
            w = f + u[y],
            x = f - u[g];
          f = st(w, f, x);
        }
        if (o) {
          let y = d === "y" ? "top" : "left",
            g = d === "y" ? "bottom" : "right",
            w = h + u[y],
            x = h - u[g];
          h = st(w, h, x);
        }
        let p = s.fn({ ...e, [m]: f, [d]: h });
        return { ...p, data: { x: p.x - n, y: p.y - i } };
      },
    };
  };
var Ft = function (t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      let { placement: n, rects: i, platform: r, elements: a } = e,
        { apply: o = () => {}, ...s } = W(t, e),
        l = await j(e, s),
        c = F(n),
        u = L(n),
        d = I(n) === "y",
        { width: m, height: f } = i.floating,
        h,
        p;
      c === "top" || c === "bottom"
        ? (h = c,
          p = u === (await (r.isRTL == null ? void 0 : r.isRTL(a.floating))
              ? "start"
              : "end")
            ? "left"
            : "right")
        : (p = c, h = u === "end" ? "top" : "bottom");
      let y = f - l.top - l.bottom,
        g = m - l.left - l.right,
        w = _(f - l[h], y),
        x = _(m - l[p], g),
        b = !e.middlewareData.shift,
        v = w,
        $ = x;
      if (d ? $ = u || b ? _(x, g) : g : v = u || b ? _(w, y) : y, b && !u) {
        let U = H(l.left, 0),
          R = H(l.right, 0),
          D = H(l.top, 0),
          tt = H(l.bottom, 0);
        d
          ? $ = m - 2 * (U !== 0 || R !== 0 ? U + R : H(l.left, l.right))
          : v = f - 2 * (D !== 0 || tt !== 0 ? D + tt : H(l.top, l.bottom));
      }
      await o({ ...e, availableWidth: $, availableHeight: v });
      let K = await r.getDimensions(a.floating);
      return m !== K.width || f !== K.height ? { reset: { rects: !0 } } : {};
    },
  };
};
function Nt(t) {
  let e = O(t),
    n = parseFloat(e.width) || 0,
    i = parseFloat(e.height) || 0,
    r = T(t),
    a = r ? t.offsetWidth : n,
    o = r ? t.offsetHeight : i,
    s = G(n) !== a || G(i) !== o;
  return s && (n = a, i = o), { width: n, height: i, $: s };
}
function gt(t) {
  return P(t) ? t : t.contextElement;
}
function X(t) {
  let e = gt(t);
  if (!T(e)) return C(1);
  let n = e.getBoundingClientRect(),
    { width: i, height: r, $: a } = Nt(e),
    o = (a ? G(n.width) : n.width) / i,
    s = (a ? G(n.height) : n.height) / r;
  return (!o || !Number.isFinite(o)) && (o = 1),
    (!s || !Number.isFinite(s)) && (s = 1),
    { x: o, y: s };
}
var ne = C(0);
function Wt(t) {
  let e = A(t);
  return !nt() || !e.visualViewport
    ? ne
    : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop };
}
function re(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== A(t) ? !1 : e;
}
function V(t, e, n, i) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  let r = t.getBoundingClientRect(), a = gt(t), o = C(1);
  e && (i ? P(i) && (o = X(i)) : o = X(t));
  let s = re(a, n, i) ? Wt(a) : C(0),
    l = (r.left + s.x) / o.x,
    c = (r.top + s.y) / o.y,
    u = r.width / o.x,
    d = r.height / o.y;
  if (a) {
    let m = A(a), f = i && P(i) ? A(i) : i, h = m, p = rt(h);
    for (; p && i && f !== h;) {
      let y = X(p),
        g = p.getBoundingClientRect(),
        w = O(p),
        x = g.left + (p.clientLeft + parseFloat(w.paddingLeft)) * y.x,
        b = g.top + (p.clientTop + parseFloat(w.paddingTop)) * y.y;
      l *= y.x,
        c *= y.y,
        u *= y.x,
        d *= y.y,
        l += x,
        c += b,
        h = A(p),
        p = rt(h);
    }
  }
  return z({ width: u, height: d, x: l, y: c });
}
function oe(t) {
  let { elements: e, rect: n, offsetParent: i, strategy: r } = t,
    a = r === "fixed",
    o = E(i),
    s = e ? Q(e.floating) : !1;
  if (i === o || s && a) return n;
  let l = { scrollLeft: 0, scrollTop: 0 }, c = C(1), u = C(0), d = T(i);
  if ((d || !d && !a) && ((M(i) !== "body" || q(o)) && (l = Z(i)), T(i))) {
    let m = V(i);
    c = X(i), u.x = m.x + i.clientLeft, u.y = m.y + i.clientTop;
  }
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y,
  };
}
function ae(t) {
  return Array.from(t.getClientRects());
}
function mt(t, e) {
  let n = Z(t).scrollLeft;
  return e ? e.left + n : V(E(t)).left + n;
}
function le(t) {
  let e = E(t),
    n = Z(t),
    i = t.ownerDocument.body,
    r = k(e.scrollWidth, e.clientWidth, i.scrollWidth, i.clientWidth),
    a = k(e.scrollHeight, e.clientHeight, i.scrollHeight, i.clientHeight),
    o = -n.scrollLeft + mt(t),
    s = -n.scrollTop;
  return O(i).direction === "rtl" && (o += k(e.clientWidth, i.clientWidth) - r),
    { width: r, height: a, x: o, y: s };
}
function se(t, e) {
  let n = A(t),
    i = E(t),
    r = n.visualViewport,
    a = i.clientWidth,
    o = i.clientHeight,
    s = 0,
    l = 0;
  if (r) {
    a = r.width, o = r.height;
    let c = nt();
    (!c || c && e === "fixed") && (s = r.offsetLeft, l = r.offsetTop);
  }
  return { width: a, height: o, x: s, y: l };
}
function ce(t, e) {
  let n = V(t, !0, e === "fixed"),
    i = n.top + t.clientTop,
    r = n.left + t.clientLeft,
    a = T(t) ? X(t) : C(1),
    o = t.clientWidth * a.x,
    s = t.clientHeight * a.y,
    l = r * a.x,
    c = i * a.y;
  return { width: o, height: s, x: l, y: c };
}
function Bt(t, e, n) {
  let i;
  if (e === "viewport") i = se(t, n);
  else if (e === "document") i = le(E(t));
  else if (P(e)) i = ce(e, n);
  else {
    let r = Wt(t);
    i = { ...e, x: e.x - r.x, y: e.y - r.y };
  }
  return z(i);
}
function zt(t, e) {
  let n = S(t);
  return n === e || !P(n) || N(n) ? !1 : O(n).position === "fixed" || zt(n, e);
}
function fe(t, e) {
  let n = e.get(t);
  if (n) return n;
  let i = B(t, [], !1).filter((s) => P(s) && M(s) !== "body"),
    r = null,
    a = O(t).position === "fixed",
    o = a ? S(t) : t;
  for (; P(o) && !N(o);) {
    let s = O(o), l = it(o);
    !l && s.position === "fixed" && (r = null),
      (a ? !l && !r : !l && s.position === "static" && r &&
            ["absolute", "fixed"].includes(r.position) ||
          q(o) && !l && zt(t, o))
        ? i = i.filter((c) => c !== o)
        : r = s,
      o = S(o);
  }
  return e.set(t, i), i;
}
function ue(t) {
  let { element: e, boundary: n, rootBoundary: i, strategy: r } = t,
    a = [
      ...n === "clippingAncestors" ? Q(e) ? [] : fe(e, this.i) : [].concat(n),
      i,
    ],
    o = a[0],
    s = a.reduce((l, c) => {
      let u = Bt(e, c, r);
      return l.top = k(u.top, l.top),
        l.right = Y(u.right, l.right),
        l.bottom = Y(u.bottom, l.bottom),
        l.left = k(u.left, l.left),
        l;
    }, Bt(e, o, r));
  return {
    width: s.right - s.left,
    height: s.bottom - s.top,
    x: s.left,
    y: s.top,
  };
}
function de(t) {
  let { width: e, height: n } = Nt(t);
  return { width: e, height: n };
}
function me(t, e, n) {
  let i = T(e),
    r = E(e),
    a = n === "fixed",
    o = V(t, !0, a, e),
    s = { scrollLeft: 0, scrollTop: 0 },
    l = C(0);
  if (i || !i && !a) {
    if ((M(e) !== "body" || q(r)) && (s = Z(e)), i) {
      let f = V(e, !0, a, e);
      l.x = f.x + e.clientLeft, l.y = f.y + e.clientTop;
    } else r && (l.x = mt(r));
  }
  let c = 0, u = 0;
  if (r && !i && !a) {
    let f = r.getBoundingClientRect();
    u = f.top + s.scrollTop, c = f.left + s.scrollLeft - mt(r, f);
  }
  let d = o.left + s.scrollLeft - l.x - c, m = o.top + s.scrollTop - l.y - u;
  return { x: d, y: m, width: o.width, height: o.height };
}
function dt(t) {
  return O(t).position === "static";
}
function Mt(t, e) {
  if (!T(t) || O(t).position === "fixed") return null;
  if (e) return e(t);
  let n = t.offsetParent;
  return E(t) === n && (n = n.ownerDocument.body), n;
}
function jt(t, e) {
  let n = A(t);
  if (Q(t)) return n;
  if (!T(t)) {
    let r = S(t);
    for (; r && !N(r);) {
      if (P(r) && !dt(r)) return r;
      r = S(r);
    }
    return n;
  }
  let i = Mt(t, e);
  for (; i && xt(i) && dt(i);) i = Mt(i, e);
  return i && N(i) && dt(i) && !it(i) ? n : i || vt(t) || n;
}
var ge = async function (t) {
  let e = this.getOffsetParent || jt,
    n = this.getDimensions,
    i = await n(t.floating);
  return {
    reference: me(t.reference, await e(t.floating), t.strategy),
    floating: { x: 0, y: 0, width: i.width, height: i.height },
  };
};
function pe(t) {
  return O(t).direction === "rtl";
}
var he = {
  convertOffsetParentRelativeRectToViewportRelativeRect: oe,
  getDocumentElement: E,
  getClippingRect: ue,
  getOffsetParent: jt,
  getElementRects: ge,
  getClientRects: ae,
  getDimensions: de,
  getScale: X,
  isElement: P,
  isRTL: pe,
};
function ye(t, e) {
  let n = null, i, r = E(t);
  function a() {
    var s;
    clearTimeout(i), (s = n) == null || s.disconnect(), n = null;
  }
  function o(s, l) {
    s === void 0 && (s = !1), l === void 0 && (l = 1), a();
    let { left: c, top: u, width: d, height: m } = t.getBoundingClientRect();
    if (s || e(), !d || !m) return;
    let f = J(u),
      h = J(r.clientWidth - (c + d)),
      p = J(r.clientHeight - (u + m)),
      y = J(c),
      g = {
        rootMargin: -f + "px " + -h + "px " + -p + "px " + -y + "px",
        threshold: k(0, Y(1, l)) || 1,
      },
      w = !0;
    function x(b) {
      let v = b[0].intersectionRatio;
      if (v !== l) {
        if (!w) return o();
        v ? o(!1, v) : i = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      w = !1;
    }
    try {
      n = new IntersectionObserver(x, { ...g, root: r.ownerDocument });
    } catch {
      n = new IntersectionObserver(x, g);
    }
    n.observe(t);
  }
  return o(!0), a;
}
function Vt(t, e, n, i) {
  i === void 0 && (i = {});
  let {
      ancestorScroll: r = !0,
      ancestorResize: a = !0,
      elementResize: o = typeof ResizeObserver == "function",
      layoutShift: s = typeof IntersectionObserver == "function",
      animationFrame: l = !1,
    } = i,
    c = gt(t),
    u = r || a ? [...c ? B(c) : [], ...B(e)] : [];
  u.forEach((g) => {
    r && g.addEventListener("scroll", n, { passive: !0 }),
      a && g.addEventListener("resize", n);
  });
  let d = c && s ? ye(c, n) : null, m = -1, f = null;
  o && (f = new ResizeObserver((g) => {
    let [w] = g;
    w && w.target === c && f &&
    (f.unobserve(e),
      cancelAnimationFrame(m),
      m = requestAnimationFrame(() => {
        var x;
        (x = f) == null || x.observe(e);
      })), n();
  }),
    c && !l && f.observe(c),
    f.observe(e));
  let h, p = l ? V(t) : null;
  l && y();
  function y() {
    let g = V(t);
    p &&
    (g.x !== p.x || g.y !== p.y || g.width !== p.width ||
      g.height !== p.height) &&
    n(),
      p = g,
      h = requestAnimationFrame(y);
  }
  return n(), () => {
    var g;
    u.forEach((w) => {
      r && w.removeEventListener("scroll", n),
        a && w.removeEventListener("resize", n);
    }),
      d?.(),
      (g = f) == null || g.disconnect(),
      f = null,
      l && cancelAnimationFrame(h);
  };
}
var $t = j, qt = kt, _t = St, It = Ht;
var Xt = Ft, Kt = Dt;
var Ut = (t, e, n) => {
  let i = new Map(), r = { platform: he, ...n }, a = { ...r.platform, i };
  return Ct(t, e, { ...r, platform: a });
};
if (typeof window < "u") {
  class t extends HTMLElement {
    constructor() {
      super(),
        this.attachShadow({ mode: "open", delegatesFocus: !0 }),
        this.open = !1,
        this.t = null;
    }
    static get observedAttributes() {
      return ["open"];
    }
    connectedCallback() {
      this.render(),
        this.addEventListener("focus", () => this.focus()),
        document.addEventListener("click", this.clickOutsideHandler.bind(this));
    }
    disconnectedCallback() {
      this.removeEventListener("focus", () => this.focus()),
        document.removeEventListener(
          "click",
          this.clickOutsideHandler.bind(this),
        ),
        this.t && this.t();
    }
    attributeChangedCallback(n, i, r) {
      n === "open" && (this.open = r !== null, this.render(), this.n());
    }
    render() {
      let n = `
      :host {
        display: inline-flex;
        min-height: 0;
        position: relative;
        width: fit-content;
        visibility: hidden;
      }

      :host > * {
        visibility: visible;
      }

      [part="dropmenu"] {
        --bg: var(--clr-surface);
        --gap: 0;
        --outln-clr: var(--bg);
        --spacing: var(--xs);

        background-color: var(--bg);
        display: grid;
        grid-template-columns: 1fr;
        grid-template-rows: 1fr;
        height: max-content;
        isolation: isolate;
        max-height: calc(clamp(16dvh, 25dvh, 32dvh) + var(--xl));
        max-width: calc(100dvw - var(--sm));
        min-height: max-content;
        min-width: max-content;
        outline: solid color-mix(in var(--config-colorSpace, srgb), var(--outln-clr), gray 16%);
        overflow: clip;
        padding: var(--spacing);
        place-content: center;
        position: fixed;
        transition: top var(--animDefaults), bottom var(--animDefaults),
          opacity var(--animDefaults), visibility var(--animDefaults);
        z-index: 1000000;
      }

      [part="dropmenu__inner"] {
        --percent: 16%;

        background-color: var(--bg);
        display: grid;
        grid-auto-flow: row;
        grid-auto-rows: max-content;
        overflow-x: clip;
        overflow-y: auto;
        transition-delay: var(--animDuration);
      }

      div::-webkit-scrollbar {
        display: none;
      }

      ::slotted(button) {
        --radius: calc(var(--sm) / 2) !important;
        width: 100% !important;
      }
    `;
      if (!this.shadowRoot) throw Error("shadowroot is null");
      this.shadowRoot.innerHTML = `
      <style>${n}</style>
      <slot name="summary" tabindex="0"></slot>
      ${
        this.open
          ? `
        <div part="dropmenu">
          <div part="dropmenu__inner">
            <slot></slot>
          </div>
        </div>
      `
          : ""
      }
    `,
        this.shadowRoot.querySelector('slot[name="summary"]').addEventListener(
          "click",
          this.r.bind(this),
        );
    }
    clickOutsideHandler(n) {
      let i = n.composedPath()[0],
        r = !this.shadowRoot.contains(i) && !this.contains(i);
      this.open && r && (this.open = !1, this.removeAttribute("open"));
    }
    r() {
      this.t && this.t(),
        this.open = !this.open,
        this.open
          ? this.setAttribute("open", "")
          : this.removeAttribute("open");
    }
    e(n) {
      let i = globalThis.devicePixelRatio || 1;
      return Math.round(n * i) / i;
    }
    n() {
      let n = this.shadowRoot.querySelector('slot[name="summary"]')
          .assignedElements()[0],
        i = this.shadowRoot.querySelector('[part="dropmenu"]');
      n && i && this.open
        ? this.t = Vt(n, i, async () => {
          let { x: r, y: a, middlewareData: o } = await Ut(n, i, {
            middleware: [
              _t({
                autoAlignment: !0,
                alignment: "bottom",
                allowedPlacements: ["top", "bottom"],
                crossAxis: !0,
                padding: 3,
              }),
              qt(3),
              It({ crossAxis: !0, mainAxis: !0, padding: 3 }),
              Xt({
                apply({ rects: s, elements: l }) {
                  Object.assign(l.floating.style, {
                    width: `${s.reference.width}px`,
                  });
                },
              }),
              {
                name: "detectOverflow",
                async fn(s) {
                  return await $t(s, {
                    altBoundary: !0,
                    boundary: document.documentElement,
                    elementContext: "floating",
                    padding: 3,
                    rootBoundary: {
                      x: 0,
                      y: 0,
                      width: document.documentElement.clientWidth,
                      height: document.documentElement.clientHeight,
                    },
                  }),
                    {};
                },
              },
              Kt(),
            ],
            placement: "bottom",
            strategy: "fixed",
          });
          o.hide &&
          Object.assign(i.style, {
            opacity: o.hide.referenceHidden ? "0" : "1",
            pointerEvents: o.hide.referenceHidden ? "none" : "initial",
          }),
            Object.assign(i.style, {
              left: "0",
              top: "0",
              transform: `translate(${this.e(r)}px, ${this.e(a)}px)`,
            });
        }, { animationFrame: !0 })
        : this.t && (this.t(), this.t = null);
    }
  }
  customElements.define("cat-dropdown", t);
}
